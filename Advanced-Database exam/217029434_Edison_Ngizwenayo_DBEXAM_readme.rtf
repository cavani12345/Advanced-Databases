{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 ArialMT;\f2\froman\fcharset0 Times-Roman;
\f3\fnil\fcharset128 HiraginoSans-W3;\f4\fnil\fcharset0 HelveticaNeue;\f5\fnil\fcharset0 LucidaGrande;
\f6\froman\fcharset0 TimesNewRomanPS-BoldMT;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww23640\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Names: Edison Ngizwenayo\
Reg no: 217029434\
Module: ADVANCED DATABASE TECHNOLOGY\
\
\
Case Study: LOGISTICS FLEET & MAINTENANCE\
\
                \
\
Introduction  \
\
This document presents the methodologies, technologies, and practical approaches applied to address the questions in the Logistics Fleet & Maintenance case study, which formed part of the Final Advanced Database Systems Examination.  The examination simulated real-world database implementation scenarios, encompassing both foundational and advanced concepts such as database and schema design, referential integrity enforcement, stored procedures and triggers, query optimization, distributed and parallel data processing, configuration tuning, and intelligent database systems. \
\
The exam was divided into two major areas:  1. Parallel and Distributed Databases  which covering topics such as fragmentation of tables, remote database links, parallel versus serial query processing, and distributed lock conflict resolution.  2. Intelligent Databases  which  focusing on advanced reasoning and automation capabilities through declarative rule hardening, triggered functions, recursive hierarchies, and the development of a mini knowledge base with transitive inference. \
\
\
Technologies  Used:\
In the implementation, I used PostgreSQL (version 16) as the database engine and pgAdmin as the client interface for managing, interacting with, and manipulating the database server.  \
\
\
\
\
The exam had  two section A and B, and all questions were mandatory. \
\
SECTION A:\
\
Question A1.1: Create horizontally fragmented tables Shipment_A on Node_A and Shipment_B on Node_B\
using a deterministic rule (HASH or RANGE on a natural key).\
 \
=== Answer ==\
\
To achieve horizontal fragmentation of the shipment table into two fragments: Shipment_A on Node_A and Shipment_B on Node_B.  The status column was used as the fragmentation criterion. Specifically, Shipment_A stores all shipments with a status of \'91Pending\'92 or \'91Canceled\'92, while Shipment_B contains shipments with a status of \'91In Transit\'92 or \'91Delivered\'92. This approach effectively demonstrates horizontal fragmentation, as it divides the table into subsets of rows based on a logical condition (shipment status), ensuring that each fragment holds distinct but structurally identical data.\
\
Since the shipment table depends on several related entities, it is essential to first create the supporting tables : vehicles, routes, drivers, maintenance, and payments, to maintain referential integrity within the database. These tables define the necessary parent relationships that ensure consistency and enforce valid references across the distributed system. Below is the DDL definition for all the relevant tables\
\
-- 1. DDL for vehicles tables\
CREATE TABLE IF NOT EXISTS vehicles (\
    vehicle_id SERIAL PRIMARY KEY,  -- Unique identifier for each vehicle\
    model VARCHAR(100) NOT NULL,    -- Vehicle model name\
    plate_no VARCHAR(20) NOT NULL UNIQUE, -- Unique license plate number\
    type VARCHAR(50) NOT NULL,      -- Vehicle type (e.g., Truck, Van)\
    status VARCHAR(20) NOT NULL CHECK (status IN ('Active', 'In Transit', 'Under Maintenance','Retired')), -- Current status of the vehicle\
    capacity INT NOT NULL CHECK (capacity > 0) -- Maximum load capacity\
);\
\
-- 2. Drivers Table: Stores driver details\
CREATE TABLE IF NOT EXISTS drivers (\
    driver_id SERIAL PRIMARY KEY,   -- Unique identifier for each driver\
    full_name VARCHAR(100) NOT NULL,  -- full name of the driver\
    license_no VARCHAR(50) NOT NULL UNIQUE, -- Driver's license number\
    contact VARCHAR(50),            -- Contact information\
    experience_years INT NOT NULL CHECK (experience_years >= 0) -- Experience in years\
);\
\
-- 3. Routes Table: Stores predefined delivery routes\
CREATE TABLE IF NOT EXISTS routes (\
    route_id SERIAL PRIMARY KEY,    -- Unique route identifier\
    start_location VARCHAR(100) NOT NULL, -- Starting point\
    end_location VARCHAR(100) NOT NULL,   -- Destination\
    distance_km DECIMAL(10,2) NOT NULL CHECK (distance_km > 0), -- Distance in kilometers with precision of 10 and 2 digits after decimal point\
    type VARCHAR(50) NOT NULL CHECK (type IN ('Urban','Rural','Long-Haul')) -- Route type classification\
);\
\
-- Maintenance Table: Tracks vehicle maintenance activities\
CREATE TABLE IF NOT EXISTS maintenance (\
    maintenance_id SERIAL PRIMARY KEY, -- Unique maintenance record\
    vehicle_id INT NOT NULL,           -- Vehicle undergoing maintenance\
    maintenance_date TIMESTAMP NOT NULL, \
    cost DECIMAL(10,2) NOT NULL CHECK (cost >= 0), -- Maintenance cost\
    description TEXT                -- Optional details about maintenance\
	\
	CONSTRAINT fk_vehicle_maitenance FOREIGN KEY (vehicle_id) REFERENCES vehicles(vehicle_id)\
);\
\
-- Payments Table: Stores payments linked to shipments\
CREATE TABLE IF NOT EXISTS payments (\
    payment_id SERIAL PRIMARY KEY,     -- Unique payment identifier\
    shipment_id INT NOT NULL UNIQUE,   -- Each shipment can have only one payment\
    amount DECIMAL(10,2) NOT NULL CHECK (amount >= 0), -- Payment amount\
    method VARCHAR(50) NOT NULL CHECK (method IN ('Cash','Bank','Mobile Money')), -- Payment method\
    payment_date TIMESTAMP NOT NULL   -- Date of payment\
	\
	CONSTRAINT fk_shipment_payments FOREIGN KEY (shipment_id) REFERENCES Shipment_A(shipment_id)\
);\
\
\
\pard\pardeftab720\partightenfactor0

\f1\fs29\fsmilli14667 \cf0 \expnd0\expndtw0\kerning0
Horizantally Fragments the shipments table using a status column
\f2\fs24 \

\f1\fs29\fsmilli14667 Shipment_A\'a0 contains all shipment that has status of either 'Pending','Canceled'\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \kerning1\expnd0\expndtw0 -- 
\f1\fs29\fsmilli14667 \expnd0\expndtw0\kerning0
 DDL for 
\f0\fs24 Shipment_A on Node_A
\f2 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 CREATE TABLE Shipment_A (\
    shipment_id SERIAL PRIMARY KEY,\
    vehicle_id INT NOT NULL,\
    driver_id INT NOT NULL,\
    route_id INT NOT NULL,\
    start_date TIMESTAMP,\
    end_date TIMESTAMP,\
    status VARCHAR(20) NOT NULL CHECK (status IN ('Pending', 'Canceled')),\
    CONSTRAINT fk_shipmentA_vehicle FOREIGN KEY (vehicle_id) REFERENCES vehicles(vehicle_id),\
    CONSTRAINT fk_shipmentA_driver FOREIGN KEY (driver_id) REFERENCES drivers(driver_id),\
    CONSTRAINT fk_shipmentA_route FOREIGN KEY (route_id) REFERENCES routes(route_id)\
);\kerning1\expnd0\expndtw0 \
\
\pard\pardeftab720\partightenfactor0

\f1\fs29\fsmilli14667 \cf0 \expnd0\expndtw0\kerning0
Horizantally Fragments the shipments table using a status column
\f2\fs24 \

\f1\fs29\fsmilli14667 Shipment_B\'a0 contains all shipment that has status of either 'In Transit', 'Delivered'\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \kerning1\expnd0\expndtw0 -- 
\f1\fs29\fsmilli14667 \expnd0\expndtw0\kerning0
DDL for 
\f0\fs24 Shipment_B  on Node_B
\f2 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 CREATE TABLE Shipment_B (\
    shipment_id SERIAL PRIMARY KEY,\
    vehicle_id INT NOT NULL,\
    driver_id INT NOT NULL,\
    route_id INT NOT NULL,\
    start_date TIMESTAMP,\
    end_date TIMESTAMP,\
    status VARCHAR(20) NOT NULL CHECK (status IN ('In Transit', 'Delivered')),\
    CONSTRAINT fk_shipmentA_vehicle FOREIGN KEY (vehicle_id) REFERENCES vehicles(vehicle_id),\
    CONSTRAINT fk_shipmentA_driver FOREIGN KEY (driver_id) REFERENCES drivers(driver_id),\
    CONSTRAINT fk_shipmentA_route FOREIGN KEY (route_id) REFERENCES routes(route_id)\
);\kerning1\expnd0\expndtw0 \
\
\
Question A1.2. Insert a TOTAL of \uc0\u8804 10 committed rows split across the two fragments (e.g., 5 on Node_A and 5\
on Node_B). Reuse these rows for all remaining tasks.\
\
=== Answer == \
The following queries insert a total of 10 rows, with 5 records in the Shipment_A table located on Node_A and 5 records in the Shipment_B table located on Node_B. During the insertion process, we ensured that all foreign key values correspond to valid entries in their respective parent tables, thereby preserving referential integrity across both nodes\
\
INSERT INTO Shipment_A (vehicle_id, driver_id, route_id, start_date, end_date, status)\
VALUES\
(1, 2, 3, '2025-10-20 08:00:00',NULL,'Pending'),\
(2, 1, 1, '2025-10-21 09:30:00',NULL,'Pending'),\
(3, 3, 2,  '2025-10-18 07:45:00','2025-10-19 16:20:00', 'Canceled'),\
(4, 4, 4, '2025-10-22 10:15:00', NULL,'Pending'),\
\
I\
NSERT INTO Shipment_B (vehicle_id, driver_id, route_id, start_date, end_date, status)\
VALUES\
(1, 2, 3, '2025-10-18 07:00:00', NULL, 'In Transit'),\
(2, 1, 1, '2025-10-14 08:45:00', '2025-10-14 20:15:00', 'Delivered'),\
(3, 3, 2, '2025-10-16 09:10:00', NULL, 'In Transit'),\
(4, 4, 4, '2025-10-17 07:30:00', '2025-10-17 19:00:00', 'Delivered'),\
(5, 1, 2, '2025-10-23 06:50:00', NULL, 'In Transit');\
\
\
Question A1.3.  On Node_A, create view Shipment_ALL as UNION ALL of Shipment_A and\
Shipment_B@proj_link.\
\
== Answer === \
\
Since Shipment_A resides on the local node (Node_A) and Shipment_B on a remote node (Node_B), we utilize PostgreSQL\'92s dblink extension to establish a connection between the two databases. This allows us to connect and access Shipment_B  table from remote Node_B. To enable this functionality, the dblink extension must first be created on Node_A using the sql statement  \
\
CREATE EXTENSION IF NOT EXISTS dblink;\
\
After enabling the dblink extension, we can now create a database view that consolidates data from the local Shipment_A table and the remote Shipment_B table. This unified view allows us to query data from both nodes seamlessly, eliminating the need to repeatedly write complex dblink queries to join the two tables. The query below demonstrates how this view is created.\
\
-- Create a global view combining local and remote fragments\
-- Shipment_A is local on Node_A\
-- Shipment_B is remote on Node_B, accessed via dblink\
CREATE OR REPLACE VIEW Shipment_ALL AS\
-- Select all rows from local fragment\
SELECT * \
FROM Shipment_A\
\
UNION ALL  -- Combine with remote fragment, keeping duplicates if any\
\
-- Fetch remote fragment Shipment_B using dblink\
SELECT *\
FROM dblink(\
    -- Connection string to remote Node_B database\
    'host=localhost port=5432 dbname=Node_B user=postgres password=postgres',\
    \
    -- SQL query to run on the remote database\
    'SELECT shipment_id, vehicle_id, driver_id, route_id, start_date, end_date, status FROM Shipment_B'\
) AS remote_shipments(\
    -- Define column names and data types for the remote query result\
    shipment_id INT,\
    vehicle_id INT,\
    driver_id INT,\
    route_id INT,\
    start_date TIMESTAMP,\
    end_date TIMESTAMP,\
    status VARCHAR(20)\
);\
\
\
Question A1.4 Validate with COUNT(*) and a checksum on a key column (e.g., SUM(MOD(primary_key,97))):results must match fragments vs Shipment_ALL.\
\
== Answer ==\
To validate the data integrity, I computed the checksum on the primary key for each fragmented table and compared the results with the checksum from the consolidated database view (Shipment_ALL).  The queries used are as follows:  \
\
Checksum on the primary key for Shipment_A:  \
-- Local fragment\
SELECT SUM(MOD(shipment_id, 97)) AS checksum_local FROM Shipment_A;\
\
\
Checksum on the primary key for Shipment_B on remote Node_B: \
-- Remote fragment via dblink\
SELECT SUM(MOD(shipment_id, 97)) AS checksum_remote\
FROM dblink(\
    'host=localhost port=5432 dbname=Node_B user=postgres password=postgres',\
    'SELECT shipment_id FROM Shipment_B'\
) AS remote_shipments(shipment_id INT);\
\
 \
Checksum on the primary key for the consolidated view Shipment_ALL: \
-- Checksum for global view\
SELECT SUM(MOD(shipment_id, 97)) AS checksum_global FROM Shipment_ALL;\
\
\
Question A2.1. From Node_A, create database link 'proj_link' to Node_B.\
To allow to both two databases to communicate we have used Foreign Data Wrapper(FDW)  This enable access to tables in another database as if they were a local database. Below is the query to create connect between Node_A and Node_B.  Below is the queries for achieving the database link\
\
--  enable FDW, \
CREATE EXTENSION IF NOT EXISTS postgres_fdw;\
\
-- Create a foreign server \
CREATE SERVER NodeB_connect\
FOREIGN DATA WRAPPER postgres_fdw\
OPTIONS (\
    host 'localhost',       -- host where Node_B is running\
    dbname 'Node_B',  -- remote db to connect to\
    port '5432'\
);\
\
-- create a user mapping(Map a local user in FleetSupport node  to a user in FleetOperations node)\
CREATE USER MAPPING FOR postgres  -- or your local user\
SERVER NodeB_connect\
OPTIONS (\
    user 'postgres',         -- Node_B username\
    password 'postgres'       -- Node_B password\
);\
\
-- import  foreign tables from \
IMPORT FOREIGN SCHEMA public\
LIMIT TO (Shipment_B)\
FROM SERVER NodeB_connect INTO public;\
\
\
Question A2.2 Run remote SELECT on Vehicle@proj_link showing up to 5 sample rows.\
\
== answer ===\
After enabling and creating a server that link to  Node_B , we can then access all tables from this node as if they are on local node.\
\
SELECT *  FROM Shipment_B\
LIMIT 5\
\
Question A2.3. Run a distributed join: local Shipment_A (or base Shipment) joined with remote\
Driver@proj_link returning between 3 and 10 rows total; include selective predicates to stay within\
the row budget.\
\
== Answer === \
\
The following is query the perform distributed join to generate number of vehicle per shipment status.\
\
SELECT s.status,COUNT(v.vehicle_id) FROM Shipment_B s\
INNER JOIN vehicles v ON v.vehicle_id = s.vehicle_id\
GROUP BY 1\
\
\
Question A3.1 Run a SERIAL aggregation on Shipment_ALL over the small dataset (e.g., totals by a domain\
column). Ensure result has 3\'9610 groups/rows.\
\
== Answer ==\
By default, PostgreSQL supports parallel query execution. To simulate serial aggregation, we need to disable this behavior by setting the configuration parameter max_parallel_workers_per_gather to 0. This parameter determines the maximum number of parallel workers that can be used to execute a single query.  The following query demonstrates how to perform serial aggregation on the Shipment_ALL view:\
\
SET max_parallel_workers_per_gather = 0;   -- Disable parallelism\
EXPLAIN ANALYZE\
SELECT -- Aggregate total shipments by status\
    status,\
    COUNT(*) AS total_shipments\
FROM Shipment_ALL\
GROUP BY status\
ORDER BY status;\
\
\
Question A3.2 Run the same aggregation with /*+ PARALLEL(Shipment_A,8) PARALLEL(Shipment_B,8) */\
to force a parallel plan despite small size.\
\
== Answer == \
To re-enable parallel query execution, which was previously disabled, we need to set the configuration parameter max_parallel_workers_per_gather to a value greater than 0. In this case, we configure it to use 8 parallel workers.  The following query demonstrates how to enable parallelism with 8 workers:\
\
SET max_parallel_workers_per_gather = 8;   -- Enable parallelism  and use 8 workers as per instruction\
EXPLAIN ANALYZE\
SELECT -- Aggregate total shipments by status\
    status,\
    COUNT(*) AS total_shipments\
FROM Shipment_ALL\
GROUP BY status\
ORDER BY status;\
\
\
Question A3.3 Capture execution plans with DBMS_XPLAN and show AUTOTRACE statistics; timings may\
be similar due to small data.\
\
== Answer ===\
Since we are using PostgreSQL, we did not use DBMS_XPLAN (which is specific to Oracle). Instead, we used the EXPLAIN ANALYZE command. This keyword provides detailed execution statistics, including all the steps involved in running the query, the planning time, and the execution time.  EXPLAIN ANALYZE is particularly useful for query optimization, as it highlights which parts of the query consume the most time during execution.  The following query demonstrates how to use EXPLAIN ANALYZE\
\
EXPLAIN ANALYZE\
SELECT -- Aggregate total shipments by status\
    status,\
    COUNT(*) AS total_shipments\
FROM Shipment_ALL\
GROUP BY status\
ORDER BY status;\
\
\
Question A4. Write one PL/SQL block that inserts ONE local row (related to Shipment) on Node_A and ONE\
\
=== Answer ====\
The following PL code insert data on both the local (Shipment_A table) and remote (payments table via dblink) databases within a single atomic operation. First, it inserts a new shipment into the local shipments table and captures the generated shipment_id. It then constructs a remote SQL statement using that shipment_id to insert a corresponding payment record into the remote database. The entire operation is atomic, meaning that if any part of the process fails either the local or remote insert the entire transaction will be rolled back, ensuring no partial updates occur. Conversely, if both inserts succeed without issues, the transaction is committed, guaranteeing consistent data across both nodes. \
\
DO $$\
DECLARE\
    -- Define variable to store the shipment_id generated by the local insert\
    new_shipment_id INT;\
	\
	-- Define variable to hold the remote SQL statement for dblink execution\
    remote_sql TEXT; \
BEGIN\
    -- Insert a new shipment into the 'shipments' table at Node 1(local DB)\
    INSERT INTO Shipment_A (vehicle_id, driver_id, route_id, start_date, end_date, status)\
    VALUES (3, 3, 4, CURRENT_DATE, CURRENT_DATE + INTERVAL '2 days', 'Pending')\
    RETURNING shipment_id INTO new_shipment_id; -- captures the generated shipment_id into a PL/pgSQL variable\
\
    -- Log the newly generated shipment_id for debugging\
    RAISE NOTICE 'New shipment_id = %', new_shipment_id;\
\
    -- Prepare the remote SQL for inserting a payment into Node 2\
    -- Use format() with %L to safely quote the shipment_id literal\
    remote_sql := format($sql$\
        INSERT INTO payments (shipment_id, amount, method, payment_date)\
        VALUES (%L, 10000, 'Mobile Money', CURRENT_DATE);\
    $sql$, new_shipment_id);\
\
    -- Execute the remote insert using dblink_exec\
    PERFORM dblink_exec(\
        'dbname=Node_B user=postgres password=postgres host=localhost port=5432',\
        remote_sql\
    );\
\
    -- Confirm both inserts succeeded\
    RAISE NOTICE 'Data inserted successfully on both nodes.';\
\
EXCEPTION\
    -- Exception handling: log the error and re-raise it for further debugging\
    WHEN OTHERS THEN\
        RAISE NOTICE 'Transaction failed: %', SQLERRM;\
        RAISE;\
END;\
$$;\
\
\
Question A4.2. Induce a failure in a second run (e.g., disable the link between inserts) to create an in-doubt\
\
== Answer ===\
In this step, we intentionally simulate a connection failure to Node_B by providing incorrect authentication details. Specifically, we attempt to connect to the remote database using the username postgres and the password post, which are invalid credentials. This deliberate misconfiguration helps us observe how the system handles authentication errors and connection failures when communication with Node_B is disrupted. Below is the PL code that simulate the failure.\
\
\
DO $$\
DECLARE\
    local_shipment_id INT;   -- Variable to hold the newly inserted shipment ID\
    remote_sql TEXT;         -- Variable to hold dynamically generated remote SQL command\
    remote_gid TEXT;         -- Global transaction ID (GID) for the remote database transaction\
    local_gid TEXT;          -- Global transaction ID (GID) for the local database transaction\
BEGIN\
    -- Step 1: Insert a new shipment record locally in the 'shipments' table.\
    -- The generated shipment_id is captured into the 'local_shipment_id' variable.\
    INSERT INTO Shipment_A (vehicle_id, driver_id, route_id, start_date, end_date, status)\
    VALUES (3, 3, 4, CURRENT_DATE, CURRENT_DATE + INTERVAL '2 days', 'Canceled')\
    RETURNING shipment_id INTO local_shipment_id;\
\
    -- Step 2: Generate unique transaction identifiers (GIDs) for both local and remote transactions.\
    -- These identifiers are important for managing distributed transactions using two-phase commit.\
    local_gid := format('local_tx_%s', local_shipment_id);\
    remote_gid := format('remote_tx_%s', local_shipment_id);\
\
    -- Step 3: Log the generated identifiers for tracking.\
    RAISE NOTICE 'Local shipment_id = %, local_gid = %, remote_gid = %',\
                 local_shipment_id, local_gid, remote_gid;\
\
    -- Step 4: Simulate a remote failure, by connecting using wrong credentials\
    -- to trigger an error, representing a remote database failure scenario.\
    remote_sql := format($remote$\
        BEGIN;\
        INSERT INTO payments (shipment_id, amount, method, payment_date)\
        VALUES (%L, 10000, 'Mobile Money', CURRENT_DATE);\
        PREPARE TRANSACTION %L;\
    $remote$, local_shipment_id, remote_gid);\
\
    BEGIN\
        -- Step 5: Attempt to execute the remote transaction using dblink.\
        -- If the remote SQL fails (due to the invalid table), the exception block will capture it.\
        PERFORM dblink_exec(\
            'dbname=Node_B user=postgres password=post host=localhost port=5432',\
            remote_sql\
        );\
    EXCEPTION\
        WHEN OTHERS THEN\
            -- Step 6: Log the simulated failure for debugging and visibility.\
            -- The error message (SQLERRM) will describe the cause of failure.\
            RAISE NOTICE '
\f3 \uc0\u9888 
\f0 Remote transaction failed: %', SQLERRM;\
    END;\
\
    -- Step 7: The local transaction remains unprepared.\
    -- It can later be manually prepared or rolled back using its GID if needed.\
END;\
\
\
Question A4.3 Query DBA_2PC_PENDING; then issue COMMIT FORCE or ROLLBACK FORCE; re-verify\
consistency on both nodes.\
\
== Answer ===\
Since we used postgres  we didn\'92t  query DBA_2PC_PENDING, instead we queried  pg_prepared_xacts, this a system table that postgres used to store all unresolved prepared transaction.\
\
The following is the query to retrieve all unresolved transaction\
SELECT * FROM pg_prepared_xacts;\
\
To rollback prepared transaction, we used ROLLBACK PREPARED 'remote_tx_14\'92.  remote_tx_14 specify the GID (global identify for that specific transaction). \
\
\
Question A4.4 Repeat a clean run to show there are no pending transactions.\
\
== Answer ===\
To verified this we queries again pg_prepared_xacts to check is no more transaction present\
\
\
\
Question A5.1.1. Open Session 1 on Node_A: UPDATE a single row in Maintenance and keep the transaction open. \
\
== Answer ===\
 \
On Node_A, we initiated  a transaction for updating maintenance cost of a for  vehicle_id = 3. Below is the query to achieve this\
\
BEGIN;\
-- Lock the record by updating it (but don\'92t commit yet)\
UPDATE maintenance\
SET cost = 10000\
WHERE vehicle_id = 3;\
\
\
Question A5.2. Open Session 2 from Node_B to update the same logical row. \
\
== Answer === \
\
Since we are going to update remote table maintenance which is on node A, so on node B we are going to create a transaction that remotely updates the record in maintenance table, and since this record being updated has been locked by the first transaction the second transaction will be hanged until the first one is committed or rolled back. The following is the query that remotely updates the table.\
\
BEGIN;\
SELECT dblink_exec( -- Execute the remote update using dblink\
    'dbname=Node_A user=postgres password=postgres host=localhost port=5432',\
    $remote$\
        UPDATE maintenance\
		SET cost = 10000\
		WHERE vehicle_id = 3;\
    $remote$\
);\
\
\
Question A5.3 Query lock views (DBA_BLOCKERS/DBA_WAITERS/V$LOCK) from Node_A to show the\
waiting session.\
\
== Answer === \
Since we used postgres lock views are stored in pg_locks table, so to get all locked records on maintenance table we used the following query\
\
SELECT\
    pid,\
    locktype,\
    relation::regclass AS table_name,\
    page,\
    tuple,\
    virtualtransaction,\
    mode,\
    granted\
FROM pg_locks l\
JOIN pg_class c ON l.relation = c.oid\
WHERE c.relname = 'maintenance';\
\
\
Question A5.4. Release the lock; show Session 2 completes. Do not insert more rows; reuse the existing \uc0\u8804 10.\
\
== Answer ===\
To release lock, you can either commit or rollback  the first transaction so that the next can be unlocked and get executed. For this task we ROLLBACK the transaction to avoid because we didn\'92t the data be persisted.\
\
\
Question  B6.1 On tables Vehicle and Maintenance, add/verify NOT NULL and domain CHECK constraints\
\
== Answer ==\
In this section we implanted Declarative Rules (constains) that validating the data being inserted, this is crucial to improved accuracy and ensure database is reliable.\
NO NULL constraints prevent the column to accept null or missing value\
CHECK this constraints ensure value being inserted or updated meet predefined condition . Below is the query for achieving this\
\
-- vehicle table defintion with constraints requested\
CREATE TABLE IF NOT EXISTS vehicles (\
    vehicle_id SERIAL PRIMARY KEY,  -- Unique identifier for each vehicle\
    model VARCHAR(100) NOT NULL,    -- Vehicle model name\
    plate_no VARCHAR(20) NOT NULL UNIQUE, -- Unique license plate number\
    type VARCHAR(50) NOT NULL,      -- Vehicle type (e.g., Truck, Van)\
    status VARCHAR(20) NOT NULL CHECK (status IN ('Active', 'In Transit', 'Under Maintenance','Retired')), -- Current status of the vehicle\
    capacity INT NOT NULL CHECK (capacity > 0) -- Maximum load capacity\
);\
\
\
-- maintenance table defintion with constraints requested\
CREATE TABLE IF NOT EXISTS maintenance (\
    maintenance_id SERIAL PRIMARY KEY, -- Unique maintenance record\
    vehicle_id INT NOT NULL,           -- Vehicle undergoing maintenance\
    maintenance_date TIMESTAMP NOT NULL, \
    cost DECIMAL(10,2) NOT NULL CHECK (cost >= 0), -- Maintenance cost\
    description TEXT                -- Optional details about maintenance\
);\
\
\
\
Question B6.2. Prepare 2 failing and 2 passing INSERTs per table to validate rules, but wrap failing ones in a\
block and ROLLBACK so committed rows stay within \uc0\u8804 10 total.\
\
== Answer == \
The following  demonstrate successful insert statements, since all entry passed meet predefined conditions\
\
-- PASSING INSERTS FOR vehicles TABLE\
INSERT INTO vehicles (model, plate_no, type, status, capacity)\
VALUES \
('Toyota Hilux', 'RAD123A', 'Truck', 'Active', 3000),\
('Isuzu NPR', 'RAD456B', 'Van', 'In Transit', 2500);\
\
\
-- FAILING INSERTS FOR vehicles TABLE (Wrapped in a ROLLBACK Block)\
\
BEGIN;\
\
-- Fails due to invalid status (not in allowed list)\
INSERT INTO vehicles (model, plate_no, type, status, capacity)\
VALUES ('Mitsubishi Fuso', 'RAD789C', 'Truck', 'Broken', 4000);\
\
-- Fails due to negative capacity (violates CHECK constraint)\
INSERT INTO vehicles (model, plate_no, type, status, capacity)\
VALUES ('Nissan Caravan', 'RAD999D', 'Van', 'Active', -500);\
\
ROLLBACK;  -- Undo the failing inserts so only valid rows remain\
\
\
-- PASSING INSERTS FOR maintenance TABLE\
\
INSERT INTO maintenance (vehicle_id, maintenance_date, cost, description)\
VALUES \
(1, NOW() - INTERVAL '10 days', 50000.00, 'Engine service'),\
(2, NOW() - INTERVAL '3 days', 25000.00, 'Brake pad replacement');\
\
--- FAILING INSERTS FOR maintenance TABLE (Wrapped in a ROLLBACK Block)\
\
BEGIN;\
\
-- Fails due to negative cost (violates CHECK constraint)\
INSERT INTO maintenance (vehicle_id, maintenance_date, cost, description)\
VALUES (1, NOW(), -10000.00, 'Oil change');\
\
-- Fails due to missing vehicle_id (NULL not allowed)\
INSERT INTO maintenance (vehicle_id, maintenance_date, cost, description)\
VALUES (NULL, NOW(), 8000.00, 'Tire replacement');\
\
ROLLBACK;  -- Undo invalid inserts\
\
\
\
Question B7.1. Create an audit table Vehicle_AUDIT(bef_total NUMBER, aft_total NUMBER, changed_at TIMESTAMP, key_col VARCHAR2(64)).\
\pard\pardeftab720\partightenfactor0
\cf0 \
== Answer ==\
Below is the query to create the table  \
\
-- Vehicle_AUDIT Table Definition\
\
CREATE TABLE IF NOT EXISTS vehicle_audit (\
    bef_total NUMERIC,             -- Total before the change\
    aft_total NUMERIC,             -- Total after the change\
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- When the change occurred\
    key_col VARCHAR(64)            -- Key or identifier of the affected record\
);\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 Question B7. 2. Implement a statement-level AFTER INSERT/UPDATE/DELETE trigger on QualityCheck that recomputes denormalized totals in ProductionOrder once per statement.\
\
== Answer === \
\
 First of all we need to modify the vahicles to include total_maintenance_cost needed for the computation, below is DDL statement to achieve this\
\
ALTER TABLE vehicles \
ADD COLUMN total_maintenance_cost NUMERIC(10,2) DEFAULT 0;\
\
Below is triggered function that will get executed AFTER INSERT/UPDATE/DELETE is made on maintenance table\
\
\pard\pardeftab720\partightenfactor0
\cf0 CREATE OR REPLACE FUNCTION recompute_vehicle_totals()\
RETURNS TRIGGER AS $$\
BEGIN\
    -- Recompute and update each vehicle\'92s total maintenance cost\
    -- The subquery calculates the SUM of all maintenance costs per vehicle.\
    -- COALESCE ensures that if a vehicle has no maintenance records,\
    -- its total_maintenance_cost is set to 0 instead of NULL.\
    UPDATE vehicles v\
    SET total_maintenance_cost = COALESCE((\
        SELECT SUM(m.cost)\
        FROM maintenance m\
        WHERE m.vehicle_id = v.vehicle_id\
    ), 0);\
\
    -- Since this function will be used in a statement-level trigger,\
    -- it does not process individual rows \'97 returning NULL is required.\
    -------------------------------------------------------------------\
    RETURN NULL;\
END;\
$$ LANGUAGE plpgsql;\
\
-- Invoke procedure defined below AFTER INSERT, UPDATE, or DELETE\
\
CREATE TRIGGER trg_recompute_vehicle_totals\
AFTER INSERT OR UPDATE OR DELETE ON maintenance\
FOR EACH STATEMENT\
EXECUTE FUNCTION recompute_vehicle_totals();\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
\
Question B7. 3. Execute a small mixed DML script on CHILD affecting at most 4 rows in total; ensure net committed rows across the project remain \uc0\u8804 10.\
\
== Answer ===\
The following is the transaction that mix INSERT, UPDATE and DELETE operation, it ensure inserted and update rows respect constraints defined in the table\
-- MIXED DML transaction: Controlled maintenance record modifications\
BEGIN;\
\
-- Insert 2 new maintenance records (simulate new services)\
INSERT INTO maintenance (vehicle_id, maintenance_date, cost, description)\
VALUES\
    (1, CURRENT_TIMESTAMP - INTERVAL '2 days', 450.00, 'Engine oil replacement'),\
    (2, CURRENT_TIMESTAMP - INTERVAL '1 day', 300.00, 'Brake pad replacement');\
\
-- Update 1 existing maintenance record (adjust cost)\
UPDATE maintenance\
SET cost = cost + 50.00, description = 'Cost adjusted after inspection'\
WHERE maintenance_id = 3;\
\
-- Delete 1 old or invalid record (simulate data cleanup)\
DELETE FROM maintenance\
WHERE maintenance_id = 4;\
\
-- Commit the transaction to apply the net 4 changes\
COMMIT;\
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \expnd0\expndtw0\kerning0
B7. 4. Log before/after totals to the audit table (2\'963 audit rows).\
\
-- step 1. Log before totals\
INSERT INTO vehicle_audit (bef_total, aft_total, key_col)\
SELECT\
\'a0\'a0\'a0\'a0total_maintenance_cost AS bef_total,\
\'a0\'a0\'a0\'a0NULL AS aft_total, \'a0 \'a0 \'a0 \'a0 \'a0 -- No after value yet\
\'a0\'a0\'a0\'a0vehicle_id AS key_col\
FROM vehicles\
WHERE vehicle_id IN (1,2,3);\
\
-- Step 2: Make updates\
UPDATE vehicles\
SET total_maintenance_cost = total_maintenance_cost * 1.1\
WHERE vehicle_id IN (1,2,3);\
\
-- Step 3: Log after totals\
UPDATE vehicle_audit a\
SET aft_total = v.total_maintenance_cost\
FROM vehicles v\
WHERE CAST(a.key_col AS INTEGER) = v.vehicle_id\
  AND a.aft_total IS NULL;\
\
Note: Query the vehicle_audit  table before and after total to check the result
\f4 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \kerning1\expnd0\expndtw0 \
\
\
Question B8.1  Create table HIER(parent_id, child_id) for a natural hierarchy (domain-specific).\
\
\
== Answer ==\
The following is DDL that create  table for storing the hierarchy, and apply all required constraints\
\
-- below is HIER Table table definition\
CREATE TABLE HIER (\
    parent_id INT NOT NULL,\
    child_id INT NOT NULL,\
    PRIMARY KEY (parent_id, child_id)\
);\
\
\
Question B8.2 .Insert 6\'9610 rows forming a 3-level hierarchy.\
\
== Answer ==\
\
INSERT INTO HIER (parent_id, child_id) VALUES\
(1, 3),   -- Root 1 
\f5 \uc0\u8594 
\f0  Sub 3\
(1, 4),   -- Root 1 
\f5 \uc0\u8594 
\f0  Sub 4\
(2, 5),   -- Root 2 
\f5 \uc0\u8594 
\f0  Sub 5\
(3, 6),   -- Sub 3 
\f5 \uc0\u8594 
\f0  Product 6\
(3, 7),   -- Sub 3 
\f5 \uc0\u8594 
\f0  Product 7\
(4, 8);   -- Sub 4 
\f5 \uc0\u8594 
\f0  Product 8\
\
\
Question B8. 3. Write a recursive WITH query to produce (child_id, root_id, depth) and join to Product or its parent to compute rollups; return 6\'9610 rows total.\
\
== answer ==\
Below is the query that use recursive functionality, where it start  by retrieving  immediate parent-child links, and concatenate with result by climb up the hierarchy\
\
WITH RECURSIVE hier_rollup AS (\
    -- Base case: immediate parent-child links\
    SELECT\
        child_id,\
        parent_id AS root_id,\
        1 AS depth\
    FROM HIER\
    \
    UNION ALL\
    \
    -- Recursive step: climb up the hierarchy\
    SELECT\
        h.child_id,\
        r.root_id,\
        r.depth + 1\
    FROM HIER h\
    JOIN hier_rollup r\
      ON h.parent_id = r.child_id\
)\
SELECT child_id, root_id, depth\
FROM hier_rollup\
ORDER BY root_id, depth;\
\
\
\
Question B9. 1 Create table TRIPLE(s VARCHAR2(64), p VARCHAR2(64), o VARCHAR2(64)).\
\
== answer === \
Below is the DDL definition for TRIPLE  table with appropriate  data type and constraints \
\
--- DDL defintion to create TRIPLE Table\
CREATE TABLE TRIPLE (\
    s VARCHAR(64) NOT NULL,  -- Subject\
    p VARCHAR(64) NOT NULL,  -- Predicate\
    o VARCHAR(64) NOT NULL,  -- Object\
    PRIMARY KEY (s, p, o)\
);\
\
\
Question B9. 2. Insert 8\'9610 domain facts relevant to your project (e.g., simple type hierarchy or rule implications).\
\
== Answer ==\
Below is DML query for inserting data into TRIPLE \
\
INSERT INTO TRIPLE (s, p, o) VALUES\
('Laptop', 'isA', 'Computer'),\
('Desktop', 'isA', 'Computer'),\
('Computer', 'isA', 'Electronics'),\
('Tablet', 'isA', 'Electronics'),\
('Electronics', 'isA', 'Device'),\
('Mouse', 'isA', 'Peripheral'),\
('Keyboard', 'isA', 'Peripheral'),\
\
\pard\pardeftab720\partightenfactor0
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 Question B9. 3 Write a recursive inference query implementing transitive isA*; apply labels to base records and return up to 10 labeled rows.\
\
==  Answer == \
Below is the query for implementing transitive isA behavior and return 10 labeled rows\
WITH RECURSIVE isa_inference AS (\
    -- Base case: direct isA relationships\
    SELECT s, o, 1 AS depth\
    FROM TRIPLE\
    WHERE p = 'isA'\
    \
    UNION ALL\
    \
    -- Recursive step: infer transitive isA\
    SELECT i.s, t.o, i.depth + 1\
    FROM isa_inference i\
    JOIN TRIPLE t\
      ON i.o = t.s\
    WHERE t.p = 'isA'\
)\
SELECT s AS subject, o AS inferred_object, depth\
FROM isa_inference\
ORDER BY s, depth\
LIMIT 10;  -- limit output to \uc0\u8804 10 rows\
\
\
\
-- Step 1: Create the table\
CREATE TABLE BUSINESS_LIMITS (\
    rule_key VARCHAR(64) PRIMARY KEY,\
    threshold NUMERIC NOT NULL,\
    active CHAR(1) NOT NULL CHECK (active IN ('Y','N'))\
);\
\
-- Step 2: Seed exactly one active rule\
INSERT INTO BUSINESS_LIMITS (rule_key, threshold, active)\
VALUES ('LIMIT_001', 100000, 'Y');\
\
\
\
Question 10. Business Limit Alert (Function + Trigger) (row-budget safe)\
\
10. 1 Create BUSINESS_LIMITS(rule_key VARCHAR(64), threshold NUMBER, active CHAR(1)\
CHECK(active IN('Y','N'))) and seed exactly one active rule.\
\
== Answer ==\
-- Step 1: Create the table\
CREATE TABLE BUSINESS_LIMITS (\
    rule_key VARCHAR(64) PRIMARY KEY,\
    threshold NUMERIC NOT NULL,\
    active CHAR(1) NOT NULL CHECK (active IN ('Y','N'))\
);\
\
-- Step 2: Seed exactly one active rule\
INSERT INTO BUSINESS_LIMITS (rule_key, threshold, active)\
VALUES ('LIMIT_001', 100000, 'Y');\
\
Step 3:  check the result of insert made by running the following query\
SELECT * FROM BUSINESS_LIMITS;\
\
10.2 . Implement function fn_should_alert(...) that reads BUSINESS_LIMITS and inspects current data\
in Maintenance or Vehicle to decide a violation (return 1/0).\
\
== Answer ==\
Below is the procedure function that read BUSINESS_LIMITS and perform the inspection  to check whether the maintenance cost exceed the threshold.\
If the result is 1 then maintenance cost exceed the threshold, otherwise not\
\
CREATE OR REPLACE FUNCTION fn_should_alert(p_vehicle_id INTEGER)\
RETURNS INTEGER AS $$\
DECLARE\
    v_threshold NUMERIC;\
    v_metric NUMERIC;\
BEGIN\
    -- Step 1: Read active threshold\
    SELECT threshold\
      INTO v_threshold\
      FROM business_limits\
     WHERE active = 'Y'\
     LIMIT 1;  -- In case there are multiple active rules\
\
    -- Step 2: Calculate metric (total maintenance cost)\
    SELECT COALESCE(SUM(cost), 0)\
      INTO v_metric\
      FROM maintenance\
     WHERE vehicle_id = p_vehicle_id;\
\
    -- Step 3: Compare with threshold\
    IF v_metric > v_threshold THEN\
        RETURN 1; -- Violation\
    ELSE\
        RETURN 0; -- No violation\
    END IF;\
\
EXCEPTION\
    WHEN NO_DATA_FOUND THEN\
        RETURN 0;  -- No active rule, assume no alert\
    WHEN OTHERS THEN\
        RETURN 0;  -- Other errors\
END;\
$$ LANGUAGE plpgsql;\
\
\'97 invoke the function and passed the foreign key value of the vehicle to check\
SELECT fn_should_alert(1) AS alert_flag;\
\
If the result of the above query  is 1 then maintenance cost exceed the threshold.\
\
10.3 3. Create a BEFORE INSERT OR UPDATE trigger on Maintenance (or relevant table) that raises\
an application error when fn_should_alert returns 1.\
\
== Answer ==\
\
The following  function raise an exception in case maintenance cost exceed the threshold \
\
-- Define a procedural function\
CREATE OR REPLACE FUNCTION trg_check_business_limit()\
RETURNS TRIGGER AS $$\
DECLARE\
    v_alert INTEGER;\
BEGIN\
    -- Step 1: Call fn_should_alert with the vehicle being modified\
    v_alert := fn_should_alert(NEW.vehicle_id);\
\
    -- Step 2: If a violation occurs, raise an error\
    IF v_alert = 1 THEN\
        RAISE EXCEPTION\
            'Business limit violation: total maintenance cost for vehicle % exceeds threshold.',\
            NEW.vehicle_id\
            USING ERRCODE = 'P0001';  -- Custom application error\
    END IF;\
\
    -- Step 3: Allow insert/update if within limit\
    RETURN NEW;\
END;\
$$ LANGUAGE plpgsql;\
\
-- Create a trigger to invoke the procedure function defined below\
CREATE TRIGGER check_business_limit\
BEFORE INSERT OR UPDATE\
ON maintenance\
FOR EACH ROW\
EXECUTE FUNCTION trg_check_business_limit();\
\
\
-- Insert a maintenance record that causes the total to exceed the limit\
INSERT INTO maintenance (vehicle_id, maintenance_date, cost, description)\
VALUES (1, NOW(), 12000000, 'Oil change');\
\
\pard\pardeftab720\partightenfactor0
\cf0 The error message will be raised because the maintenance cost for this vehicle is 12,000,00 and it exceed the threshold which is 1,000,000\
\
10. 4. Demonstrate 2 failing and 2 passing DML cases; rollback the failing ones so total committed\
rows remain within the \uc0\u8804 10 budget.\
\
== Answer == \
\
-- Two passing cases on maintenance table ensure cost <=100000\
INSERT INTO maintenance (vehicle_id, maintenance_date, cost, description)\
VALUES (1, NOW(), 1000, 'Oil change'),\
(1, NOW(), 200, 'Oil change');\
\
-- Two failing DML cases (cost exceed threshold)\
BEGIN;\
INSERT INTO maintenance (vehicle_id, maintenance_date, cost, description)\
VALUES (1, NOW(), 5000000, 'Oil change'),\
(1, NOW(),4000000, 'Oil change');\
ROLLBACK;  -- rollback failing case\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
\
\
\
 \
\
\
\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f6\b\fs32 \cf0 \expnd0\expndtw0\kerning0
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f2\b0\fs24 \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \kerning1\expnd0\expndtw0 \
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
}